<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Honey Catch</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #000; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
    <script>
        let jar, droplets = [], bees = [];
        let score = 0, lives = 3, gameOver = false;
        let lastDropletSpawn = 0, lastBeeSpawn = 0, nextBeeSpawnTime = 0;
        let fastBeeIndex = -1; // Tracks which bee is fast (dash or hunt) when 5 are present

        function setup() {
            createCanvas(800, 600);
            jar = { x: width / 2, y: height / 2, w: 50, h: 50 }; // Start jar in center
            spawnDroplet();
            spawnBee(); // Start with one bee
            nextBeeSpawnTime = millis() + 10000; // Next bee in 10 seconds
        }

        function draw() {
            console.log('Droplets:', droplets.length, 'Bees:', bees.length, 'Jar X:', jar.x, 'Jar Y:', jar.y, 'Fast Bee:', fastBeeIndex);
            // Draw meadow gradient background
            for (let y = 0; y < height; y++) {
                let c = lerpColor(color(100, 150, 255), color(50, 100, 50), y / height);
                stroke(c);
                line(0, y, width, y);
            }

            // Update jar position if mouse is pressed (dragging)
            if (mouseIsPressed && !gameOver) {
                jar.x = constrain(mouseX - jar.w / 2, 0, width - jar.w);
                jar.y = constrain(mouseY - jar.h / 2, 0, height - jar.h);
            }

            if (!gameOver) {
                // Spawn honey droplets
                if (millis() - lastDropletSpawn > 2000) {
                    spawnDroplet();
                    lastDropletSpawn = millis();
                }

                // Spawn bees (up to 5)
                if (bees.length < 5 && millis() > nextBeeSpawnTime) {
                    spawnBee();
                    lastBeeSpawn = millis();
                    nextBeeSpawnTime = millis() + (bees.length < 5 ? 10000 : 3000); // 10s for new bee, 3s for replacement
                }

                // Update and draw honey droplets
                for (let i = droplets.length - 1; i >= 0; i--) {
                    let d = droplets[i];
                    d.x += d.vx;
                    d.y += d.vy;
                    fill(255, 200, 0); // Yellow-orange for droplets
                    noStroke();
                    beginShape();
                    vertex(d.x + 10, d.y); // Top
                    bezierVertex(d.x + 15, d.y + 5, d.x + 15, d.y + 15, d.x + 10, d.y + 20); // Right curve
                    bezierVertex(d.x + 5, d.y + 15, d.x + 5, d.y + 5, d.x + 10, d.y); // Left curve
                    endShape(CLOSE);

                    // Check collision with jar
                    if (collides(jar, d)) {
                        score += 10;
                        droplets.splice(i, 1);
                        continue;
                    }
                    // Remove if off-screen
                    if (d.y > height) droplets.splice(i, 1);
                }

                // Update and draw bees
                for (let i = bees.length - 1; i >= 0; i--) {
                    let b = bees[i];
                    // Update speed phase
                    if (bees.length === 5) {
                        // Only one bee is fast (dash or hunt)
                        if (i === fastBeeIndex) {
                            // Follow phase cycle
                            if (millis() - b.phaseStart > b.phaseDuration) {
                                if (b.phase === 'slow') {
                                    b.phase = b.phaseCycleIndex % 2 === 0 ? 'dash' : 'hunt';
                                    b.phaseCycleIndex++;
                                } else {
                                    b.phase = 'slow';
                                }
                                b.phaseStart = millis();
                                b.phaseDuration = b.phase === 'slow' ? 3000 : 1000; // 3s slow, 1s dash/hunt
                            }
                        } else {
                            b.phase = 'slow'; // Others are slow
                        }
                    } else {
                        // Cycle phases normally
                        if (millis() - b.phaseStart > b.phaseDuration) {
                            if (b.phase === 'slow') {
                                b.phase = b.phaseCycleIndex % 2 === 0 ? 'dash' : 'hunt';
                                b.phaseCycleIndex++;
                            } else {
                                b.phase = 'slow';
                            }
                            b.phaseStart = millis();
                            b.phaseDuration = b.phase === 'slow' ? 3000 : 1000; // 3s slow, 1s dash/hunt
                        }
                    }

                    // Set velocity based on phase
                    if (b.phase === 'slow') {
                        let speed = random(1, 2);
                        let angle = random(TWO_PI);
                        b.vx = speed * cos(angle);
                        b.vy = speed * sin(angle);
                    } else if (b.phase === 'dash') {
                        let speed = random(5, 7);
                        let angle = random(TWO_PI);
                        b.vx = speed * cos(angle);
                        b.vy = speed * sin(angle);
                    } else { // hunt
                        let speed = random(7, 9);
                        let dx = (jar.x + jar.w / 2) - (b.x + b.w / 2);
                        let dy = (jar.y + jar.h / 2) - (b.y + b.h / 2);
                        let mag = sqrt(dx * dx + dy * dy);
                        if (mag > 0) {
                            b.vx = (dx / mag) * speed;
                            b.vy = (dy / mag) * speed;
                        } else {
                            b.vx = speed;
                            b.vy = 0;
                        }
                    }

                    b.x += b.vx;
                    b.y += b.vy;

                    // Draw bee (yellow-black hexagon)
                    fill(255, 204, 0); // Yellow
                    noStroke();
                    beginShape();
                    for (let a = 0; a < TWO_PI; a += TWO_PI / 6) {
                        let x = b.x + 15 + cos(a) * 15;
                        let y = b.y + 15 + sin(a) * 15;
                        vertex(x, y);
                    }
                    endShape(CLOSE);
                    // Black stripes
                    stroke(0);
                    strokeWeight(2);
                    line(b.x + 10, b.y + 5, b.x + 20, b.y + 5);
                    line(b.x + 10, b.y + 15, b.x + 20, b.y + 15);

                    // Check collision with jar
                    if (collides(jar, b)) {
                        lives -= 1;
                        bees.splice(i, 1);
                        if (lives <= 0) gameOver = true;
                        updateFastBeeIndex(i);
                        continue;
                    }
                    // Remove if off-screen
                    if (b.x > width || b.x < -30 || b.y > height || b.y < -30) {
                        bees.splice(i, 1);
                        updateFastBeeIndex(i);
                        continue;
                    }
                }

                // Update fast bee when five bees are present
                if (bees.length === 5 && fastBeeIndex >= 0) {
                    let fastBee = bees[fastBeeIndex];
                    if (fastBee.phase === 'slow' && millis() - fastBee.phaseStart > fastBee.phaseDuration) {
                        updateFastBeeIndex(fastBeeIndex); // Reassign fast bee
                    }
                }
            }

            // Draw honey jar
            fill(200, 150, 0); // Golden-brown
            noStroke();
            rect(jar.x, jar.y + 10, jar.w, jar.h - 10); // Jar body
            arc(jar.x + jar.w / 2, jar.y + 10, jar.w, 20, PI, TWO_PI); // Curved top

            // Draw HUD
            textSize(20);
            fill(255);
            textAlign(LEFT);
            text(`Score: ${score}`, 10, 30);
            text(`Lives: ${lives}`, 10, 60);

            // Game over screen
            if (gameOver) {
                textSize(40);
                textAlign(CENTER);
                fill(255, 0, 0);
                text('Game Over!', width / 2, height / 2);
                textSize(20);
                text('Click to Restart', width / 2, height / 2 + 40);
            }
        }

        function spawnDroplet() {
            let x = random(0, width);
            let vx = random(-1, 1);
            let vy = random(0.5, 2);
            droplets.push({ x, y: 0, vx, vy, w: 20, h: 20 });
        }

        function spawnBee() {
            let x = random(0, width);
            let y = random(0, height);
            let phase = 'slow';
            let speed = random(1, 2);
            let angle = random(TWO_PI);
            let vx = speed * cos(angle);
            let vy = speed * sin(angle);
            let phaseStart = millis();
            let phaseDuration = 3000; // Start with 3s slow
            let phaseCycleIndex = 0; // Tracks cycle for dash/hunt alternation
            bees.push({ x, y, vx, vy, w: 30, h: 30, phase, phaseStart, phaseDuration, phaseCycleIndex });
            if (bees.length === 5 && fastBeeIndex === -1) {
                fastBeeIndex = bees.length - 1; // New bee is fast
            }
        }

        function updateFastBeeIndex(removedIndex) {
            if (bees.length < 5) {
                fastBeeIndex = -1;
            } else if (fastBeeIndex === removedIndex) {
                fastBeeIndex = floor(random(bees.length));
            } else if (fastBeeIndex > removedIndex) {
                fastBeeIndex--;
            }
        }

        function collides(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
        }

        function mousePressed() {
            if (gameOver) {
                score = 0;
                lives = 3;
                gameOver = false;
                droplets = [];
                bees = [];
                fastBeeIndex = -1;
                spawnDroplet();
                spawnBee();
                lastDropletSpawn = millis();
                lastBeeSpawn = millis();
                nextBeeSpawnTime = millis() + 10000;
            }
        }
    </script>
</body>
</html>
