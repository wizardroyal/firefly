<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Honey Catch</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #000; }
        canvas { display: block; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
    <script>
        let gameState = 'intro'; // intro, teamSelect, game
        let messageOffset = 0;
        let team = null; // 'pink' or 'blue'
        let jar, droplets = [], bees = [];
        let score = 0, lives = 3, gameOver = false;
        let lastDropletSpawn = 0, lastBeeSpawn = 0, nextBeeSpawnTime = 0;
        let fastBeeIndex = -1;
        let beeImg, jarImg;

        // Intro message
        const introMessage = [
            "It's Succinct Summer,",
            "You're on a fierce secret mission,",
            "But communications were leaked,",
            "Your enemies know your location,",
            "Do you have what it takes?"
        ];

        // Buttons
        let yesButton = { x: 300, y: 450, w: 100, h: 50, color: [0, 255, 0], text: 'YES' };
        let noButton = { x: 400, y: 450, w: 100, h: 50, color: [255, 0, 0], text: 'NO' };
        let pinkButton = { x: 300, y: 400, w: 100, h: 50, color: [255, 192, 203], text: 'PINK' };
        let blueButton = { x: 400, y: 400, w: 100, h: 50, color: [0, 0, 255], text: 'BLUE' };
        let startButton = { x: 350, y: 500, w: 100, h: 50, color: [128, 128, 128], text: 'Start' };

        function preload() {
            // Placeholder base64 images (replace with real ones from GitHub)
            // Blue Team: pfly.png for bees, blue.png for jar
            // Pink Team: bfly.png for bees, pink.png for jar
            // Download from https://github.com/wizardroyal/firefly/blob/main/
            // Convert to base64 using base64-image.de
            // Example: beeImg = loadImage('data:image/png;base64,...');
            beeImg = loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAFElEQVR42mNgYGD4z8DAwPCfgQEAVCMBRnBdt9IAAAAASUVORK5CYII=');
            jarImg = loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAFElEQVR42mNg+M/AwPCfgYGBgYGBASwRBgZc9vIAAAAASUVORK5CYII=');
        }

        function setup() {
            createCanvas(800, 600);
        }

        function draw() {
            if (gameState === 'intro') {
                background(0);
                // Draw scrolling message
                textSize(24);
                fill(255);
                textAlign(CENTER);
                for (let i = 0; i < introMessage.length; i++) {
                    text(introMessage[i], width / 2, 200 + i * 40 - messageOffset);
                }
                messageOffset += 1;
                if (messageOffset > introMessage.length * 40 + 300) {
                    messageOffset = 0;
                }

                // Draw YES/NO buttons
                drawButton(yesButton);
                drawButton(noButton);
            } else if (gameState === 'teamSelect') {
                background(0);
                textSize(32);
                fill(255);
                textAlign(CENTER);
                text('Choose your team', width / 2, 300);
                drawButton(pinkButton);
                drawButton(blueButton);
                if (team) {
                    drawButton(startButton);
                }
            } else if (gameState === 'game') {
                drawGame();
            }
        }

        function drawGame() {
            console.log('Droplets:', droplets.length, 'Bees:', bees.length, 'Jar X:', jar.x, 'Jar Y:', jar.y, 'Fast Bee:', fastBeeIndex);
            // Draw meadow gradient background
            for (let y = 0; y < height; y++) {
                let c = lerpColor(color(100, 150, 255), color(50, 100, 50), y / height);
                stroke(c);
                line(0, y, width, y);
            }

            // Update jar position if mouse is pressed (dragging)
            if (mouseIsPressed && !gameOver) {
                jar.x = constrain(mouseX - jar.w / 2, 0, width - jar.w);
                jar.y = constrain(mouseY - jar.h / 2, 0, height - jar.h);
            }

            if (!gameOver) {
                // Spawn honey droplets
                if (millis() - lastDropletSpawn > 2000) {
                    spawnDroplet();
                    lastDropletSpawn = millis();
                }

                // Spawn bees (up to 5)
                if (bees.length < 5 && millis() > nextBeeSpawnTime) {
                    spawnBee();
                    lastBeeSpawn = millis();
                    nextBeeSpawnTime = millis() + (bees.length < 5 ? 10000 : 3000);
                }

                // Update and draw honey droplets
                for (let i = droplets.length - 1; i >= 0; i--) {
                    let d = droplets[i];
                    d.x += d.vx;
                    d.y += d.vy;
                    fill(255, 200, 0);
                    noStroke();
                    beginShape();
                    vertex(d.x + 10, d.y);
                    bezierVertex(d.x + 15, d.y + 5, d.x + 15, d.y + 15, d.x + 10, d.y + 20);
                    bezierVertex(d.x + 5, d.y + 15, d.x + 5, d.y + 5, d.x + 10, d.y);
                    endShape(CLOSE);

                    // Check collision with jar
                    if (collides(jar, d)) {
                        score += 10;
                        droplets.splice(i, 1);
                        continue;
                    }
                    // Remove if off-screen
                    if (d.y > height) droplets.splice(i, 1);
                }

                // Update and draw bees
                for (let i = bees.length - 1; i >= 0; i--) {
                    let b = bees[i];
                    // Update speed phase
                    if (bees.length === 5) {
                        if (i === fastBeeIndex) {
                            if (millis() - b.phaseStart > b.phaseDuration) {
                                if (b.phase === 'slow') {
                                    b.phase = b.phaseCycleIndex % 2 === 0 ? 'dash' : 'hunt';
                                    b.phaseCycleIndex++;
                                } else {
                                    b.phase = 'slow';
                                }
                                b.phaseStart = millis();
                                b.phaseDuration = b.phase === 'slow' ? 3000 : 1000;
                            }
                        } else {
                            b.phase = 'slow';
                        }
                    } else {
                        if (millis() - b.phaseStart > b.phaseDuration) {
                            if (b.phase === 'slow') {
                                b.phase = b.phaseCycleIndex % 2 === 0 ? 'dash' : 'hunt';
                                b.phaseCycleIndex++;
                            } else {
                                b.phase = 'slow';
                            }
                            b.phaseStart = millis();
                            b.phaseDuration = b.phase === 'slow' ? 3000 : 1000;
                        }
                    }

                    // Set velocity based on phase
                    if (b.phase === 'slow') {
                        let speed = random(1, 2);
                        let angle = random(TWO_PI);
                        b.vx = speed * cos(angle);
                        b.vy = speed * sin(angle);
                    } else if (b.phase === 'dash') {
                        let speed = random(5, 7);
                        let angle = random(TWO_PI);
                        b.vx = speed * cos(angle);
                        b.vy = speed * sin(angle);
                    } else { // hunt
                        let speed = random(7, 9);
                        let dx = (jar.x + jar.w / 2) - (b.x + b.w / 2);
                        let dy = (jar.y + jar.h / 2) - (b.y + b.h / 2);
                        let mag = sqrt(dx * dx + dy * dy);
                        if (mag > 0) {
                            b.vx = (dx / mag) * speed;
                            b.vy = (dy / mag) * speed;
                        } else {
                            b.vx = speed;
                            b.vy = 0;
                        }
                    }

                    b.x += b.vx;
                    b.y += b.vy;

                    // Draw bee (image)
                    image(beeImg, b.x, b.y, 30, 30);

                    // Check collision with jar
                    if (collides(jar, b)) {
                        lives -= 1;
                        bees.splice(i, 1);
                        if (lives <= 0) gameOver = true;
                        updateFastBeeIndex(i);
                        continue;
                    }
                    // Remove if off-screen
                    if (b.x > width || b.x < -30 || b.y > height || b.y < -30) {
                        bees.splice(i, 1);
                        updateFastBeeIndex(i);
                        continue;
                    }
                }

                // Update fast bee when five bees are present
                if (bees.length === 5 && fastBeeIndex >= 0) {
                    let fastBee = bees[fastBeeIndex];
                    if (fastBee.phase === 'slow' && millis() - fastBee.phaseStart > fastBee.phaseDuration) {
                        updateFastBeeIndex(fastBeeIndex);
                    }
                }
            }

            // Draw honey jar
            image(jarImg, jar.x, jar.y, jar.w, jar.h);

            // Draw HUD
            textSize(20);
            fill(255);
            textAlign(LEFT);
            text(`Score: ${score}`, 10, 30);
            text(`Lives: ${lives}`, 10, 60);

            // Game over screen
            if (gameOver) {
                textSize(40);
                textAlign(CENTER);
                fill(255, 0, 0);
                text('Game Over!', width / 2, height / 2);
                textSize(20);
                text('Click to Restart', width / 2, height / 2 + 40);
            }
        }

        function drawButton(btn) {
            fill(btn.color);
            rect(btn.x, btn.y, btn.w, btn.h);
            fill(0);
            textSize(20);
            textAlign(CENTER, CENTER);
            text(btn.text, btn.x + btn.w / 2, btn.y + btn.h / 2);
        }

        function mousePressed() {
            if (gameState === 'intro') {
                if (isMouseOverButton(yesButton)) {
                    gameState = 'teamSelect';
                } else if (isMouseOverButton(noButton)) {
                    background(0);
                    textSize(40);
                    fill(255, 0, 0);
                    textAlign(CENTER);
                    text('Mission Abandoned', width / 2, height / 2);
                    gameState = 'abandoned';
                }
            } else if (gameState === 'teamSelect') {
                if (isMouseOverButton(pinkButton)) {
                    team = 'pink';
                    // Load pink images
                    beeImg = loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAFElEQVR42mNgYGD4z8DAwPCfgQEAVCMBRnBdt9IAAAAASUVORK5CYII='); // Replace with bfly.png base64
                    jarImg = loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAFElEQVR42mNg+M/AwPCfgYGBgYGBASwRBgZc9vIAAAAASUVORK5CYII='); // Replace with pink.png base64
                } else if (isMouseOverButton(blueButton)) {
                    team = 'blue';
                    // Load blue images
                    beeImg = loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAFElEQVR42mNgYGD4z8DAwPCfgQEAVCMBRnBdt9IAAAAASUVORK5CYII='); // Replace with pfly.png base64
                    jarImg = loadImage('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAFElEQVR42mNg+M/AwPCfgYGBgYGBASwRBgZc9vIAAAAASUVORK5CYII='); // Replace with blue.png base64
                } else if (team && isMouseOverButton(startButton)) {
                    gameState = 'game';
                    jar = { x: width / 2, y: height / 2, w: 50, h: 50 };
                    spawnDroplet();
                    spawnBee();
                    nextBeeSpawnTime = millis() + 10000;
                }
            } else if (gameState === 'game' && gameOver) {
                score = 0;
                lives = 3;
                gameOver = false;
                droplets = [];
                bees = [];
                fastBeeIndex = -1;
                spawnDroplet();
                spawnBee();
                lastDropletSpawn = millis();
                lastBeeSpawn = millis();
                nextBeeSpawnTime = millis() + 10000;
            }
        }

        function isMouseOverButton(btn) {
            return mouseX > btn.x && mouseX < btn.x + btn.w && mouseY > btn.y && mouseY < btn.y + btn.h;
        }

        function spawnDroplet() {
            let x = random(0, width);
            let vx = random(-1, 1);
            let vy = random(0.5, 2);
            droplets.push({ x, y: 0, vx, vy, w: 20, h: 20 });
        }

        function spawnBee() {
            let x = random(0, width);
            let y = random(0, height);
            let phase = 'slow';
            let speed = random(1, 2);
            let angle = random(TWO_PI);
            let vx = speed * cos(angle);
            let vy = speed * sin(angle);
            let phaseStart = millis();
            let phaseDuration = 3000;
            let phaseCycleIndex = 0;
            bees.push({ x, y, vx, vy, w: 30, h: 30, phase, phaseStart, phaseDuration, phaseCycleIndex });
            if (bees.length === 5 && fastBeeIndex === -1) {
                fastBeeIndex = bees.length - 1;
            }
        }

        function updateFastBeeIndex(removedIndex) {
            if (bees.length < 5) {
                fastBeeIndex = -1;
            } else if (fastBeeIndex === removedIndex) {
                fastBeeIndex = floor(random(bees.length));
            } else if (fastBeeIndex > removedIndex) {
                fastBeeIndex--;
            }
        }

        function collides(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
        }
    </script>
</body>
</html>
