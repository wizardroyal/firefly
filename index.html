<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saving Succinct Summer</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #000; }
        canvas { display: block; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Chewy&family=Bubblegum+Sans&family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
    <script src="https://cdn.ethers.io/lib/ethers-5.7.umd.min.js"></script>
</head>
<body>
    <script>
        let gameState = 'teamSelect'; // teamSelect, intro, login, game, abandoned, leaderboard, saveScore, highScore
        let team = null; // 'pink' or 'blue'
        let jar, droplets = [], bees = [];
        let score = 0, lives = 3, gameOver = false;
        let lastDropletSpawn = 0, lastBeeSpawn = 0, nextBeeSpawnTime = 0;
        let fastBeeIndex = -1;
        let beeImg, jarImg, dropletImg;
        let pinkBeeImg, pinkJarImg, blueBeeImg, blueJarImg;
        let imagesLoaded = false;
        let walletAddress = null;
        let username = null;
        let provider, signer, contract;
        let leaderboard = [];
        let highScores = [];
        let saveScoreChoice = null;
        let scrollOffset = 0;
        let isWalletConnected = false;

        // Intro animation variables
        let introMessage = [];
        let lineIndex = 0;
        let lineAlpha = 0;
        let lineStartTime = 0;
        let showButtons = false;

        // Intro messages
        const blueIntroMessage = [
            "It's Succinct Summer,",
            "But Pink team have stolen the essence of Summer,",
            "It's up to you oh Blue knight to reclaim it back,",
            "Do you have what it takes?"
        ];
        const pinkIntroMessage = [
            "It's Succinct Summer,",
            "But Blue team have stolen the essence of Summer,",
            "It's up to you oh Pink knight to reclaim it back,",
            "Do you have what it takes?"
        ];

        // Buttons
        let walletButton = { x: 300, y: 350, w: 200, h: 50, color: [100, 150, 255], text: 'Sign in with Wallet' };
        let usernameButton = { x: 300, y: 420, w: 200, h: 50, color: [255, 100, 150], text: 'Enter Username' };
        let startGameButton = { x: 350, y: 250, w: 100, h: 50, color: [128, 128, 128], text: 'Start Game' };
        let yesButton = { x: 300, y: 450, w: 100, h: 50, color: [0, 255, 0], text: 'YES' };
        let noButton = { x: 400, y: 450, w: 100, h: 50, color: [255, 0, 0], text: 'NO' };
        let pinkButton = { x: 300, y: 400, w: 100, h: 50, color: [199, 21, 133], text: 'PINK' }; // Deep pink #C71585
        let blueButton = { x: 400, y: 400, w: 100, h: 50, color: [0, 0, 255], text: 'BLUE' };
        let leaderboardButton = { x: 620, y: 10, w: 80, h: 30, color: [0, 128, 0], text: 'Leaderboard' }; // Green
        let highScoreButton = { x: 710, y: 10, w: 80, h: 30, color: [255, 215, 0], text: 'High Scores' }; // Golden #FFD700
        let saveYesButton = { x: 300, y: 400, w: 100, h: 50, color: [0, 255, 0], text: 'YES' };
        let saveNoButton = { x: 400, y: 400, w: 100, h: 50, color: [255, 0, 0], text: 'NO' };
        let restartButton = { x: 350, y: 480, w: 100, h: 50, color: [0, 128, 0], text: 'Restart' };

        // Smart contract ABI
        const contractABI = [
            {
                "inputs": [
                    {"internalType": "uint256", "name": "_score", "type": "uint256"},
                    {"internalType": "string", "name": "_team", "type": "string"}
                ],
                "name": "saveScore",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getScores",
                "outputs": [
                    {
                        "components": [
                            {"internalType": "address", "name": "player", "type": "address"},
                            {"internalType": "uint256", "name": "score", "type": "uint256"},
                            {"internalType": "string", "name": "team", "type": "string"}
                        ],
                        "internalType": "struct SavingSuccinctSummerLeaderboard.Score[]",
                        "name": "",
                        "type": "tuple[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [{"internalType": "address", "name": "_player", "type": "address"}],
                "name": "getPlayerScores",
                "outputs": [
                    {
                        "components": [
                            {"internalType": "address", "name": "player", "type": "address"},
                            {"internalType": "uint256", "name": "score", "type": "uint256"},
                            {"internalType": "string", "name": "team", "type": "string"}
                        ],
                        "internalType": "struct SavingSuccinctSummerLeaderboard.Score[]",
                        "name": "",
                        "type": "tuple[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];
        const contractAddress = 'YOUR_CONTRACT_ADDRESS'; // Replace after deploying on Sepolia

        function preload() {
            console.log('Preloading images...');
            try {
                pinkBeeImg = loadImage('https://raw.githubusercontent.com/wizardroyal/firefly/main/bfly.png');
                pinkJarImg = loadImage('https://raw.githubusercontent.com/wizardroyal/firefly/main/pink.png');
                blueBeeImg = loadImage('https://raw.githubusercontent.com/wizardroyal/firefly/main/pfly.png');
                blueJarImg = loadImage('https://raw.githubusercontent.com/wizardroyal/firefly/main/blue.png');
                dropletImg = loadImage('https://raw.githubusercontent.com/wizardroyal/firefly/main/drop.png');
            } catch (error) {
                console.error('Image preload failed:', error);
                imagesLoaded = false;
            }
        }

        async function setup() {
            try {
                createCanvas(800, 600);
                // Check image loading
                imagesLoaded = pinkBeeImg && pinkBeeImg.width > 0 && 
                              pinkJarImg && pinkJarImg.width > 0 && 
                              blueBeeImg && blueBeeImg.width > 0 && 
                              blueJarImg && blueJarImg.width > 0 && 
                              dropletImg && dropletImg.width > 0;
                console.log('Setup complete, images loaded:', imagesLoaded);
                if (typeof window.ethereum !== 'undefined') {
                    try {
                        provider = new ethers.providers.Web3Provider(window.ethereum);
                        if (contractAddress !== 'YOUR_CONTRACT_ADDRESS') {
                            contract = new ethers.Contract(contractAddress, contractABI, provider);
                            console.log('Web3 provider initialized with contract:', contractAddress);
                        } else {
                            console.warn('No valid contract address, using local storage');
                            contract = null;
                        }
                    } catch (error) {
                        console.error('Web3 provider setup failed:', error);
                        contract = null;
                    }
                } else {
                    console.warn('No Ethereum provider detected');
                    contract = null;
                }
                loadLocalHighScores();
                console.log('Initial game state:', gameState);
            } catch (error) {
                console.error('Setup failed:', error);
            }
        }

        function draw() {
            try {
                if (gameState === 'teamSelect') {
                    background(255, 240, 245); // Whitish pink #FFF0F5
                    // Draw curved header
                    textFont('Chewy');
                    textSize(48);
                    fill(199, 21, 133); // Deep pink
                    stroke(128, 128, 128); // Gray outline
                    strokeWeight(2);
                    textAlign(CENTER);
                    let headerText = 'SAVING SUCCINCT SUMMER';
                    let radius = 300; // Arc radius for inward curve
                    let angleStep = 0.05; // Angle between letters
                    push();
                    translate(width / 2, 150);
                    for (let i = 0; i < headerText.length; i++) {
                        let angle = (i - headerText.length / 2) * angleStep;
                        push();
                        rotate(angle);
                        translate(0, -radius);
                        text(headerText[i], 0, 0);
                        pop();
                    }
                    pop();
                    noStroke();
                    textFont('Bubblegum Sans');
                    textSize(32);
                    fill(51, 51, 51);
                    text('Choose your team', width / 2, 300);
                    drawButton(pinkButton);
                    drawButton(blueButton);
                } else if (gameState === 'intro') {
                    background(255, 240, 245);
                    textFont('Bubblegum Sans');
                    textSize(24);
                    textAlign(CENTER);
                    for (let i = 0; i <= lineIndex; i++) {
                        if (i < introMessage.length) {
                            let alpha = i === lineIndex ? lineAlpha : 255;
                            fill(51, 51, 51, alpha);
                            text(introMessage[i], width / 2, 200 + i * 40);
                        }
                    }
                    if (lineIndex < introMessage.length) {
                        let elapsed = millis() - lineStartTime;
                        if (elapsed <= 2000) {
                            lineAlpha = lerp(0, 255, elapsed / 2000);
                        } else if (elapsed > 2500) {
                            lineIndex++;
                            lineAlpha = 0;
                            lineStartTime = millis();
                        }
                    } else {
                        showButtons = true;
                    }
                    if (showButtons) {
                        drawButton(yesButton);
                        drawButton(noButton);
                    }
                } else if (gameState === 'login') {
                    background(255, 240, 245);
                    if (walletAddress || username) {
                        drawButton(startGameButton);
                    }
                    drawButton(walletButton);
                    drawButton(usernameButton);
                    textFont('Bubblegum Sans');
                    textSize(20);
                    fill(51, 51, 51);
                    textAlign(CENTER);
                    text('please sign in with burner wallet', width / 2, 480);
                } else if (gameState === 'game') {
                    if (!imagesLoaded) {
                        console.log('Images not loaded, using shapes as fallback');
                    }
                    drawGame();
                } else if (gameState === 'abandoned') {
                    background(255, 240, 245);
                    textFont('Bubblegum Sans');
                    textSize(40);
                    fill(255, 0, 0);
                    textAlign(CENTER);
                    text('Mission Abandoned', width / 2, height / 2);
                } else if (gameState === 'saveScore') {
                    background(245, 230, 199);
                    textFont('Bubblegum Sans');
                    textSize(32);
                    fill(51, 51, 51);
                    textAlign(CENTER);
                    text(`Your Score: ${score}`, width / 2, 300);
                    text('Save to Leaderboard?', width / 2, 350);
                    drawButton(saveYesButton);
                    drawButton(saveNoButton);
                    drawButton(leaderboardButton);
                    drawButton(highScoreButton);
                    if (saveScoreChoice !== null) {
                        drawButton(restartButton);
                    }
                } else if (gameState === 'leaderboard') {
                    background(245, 230, 199); // Beige
                    fill(0, 128, 0); // Green
                    rect(150, 60, 500, 400); // Expanded box
                    textFont('Comic Neue');
                    textSize(32);
                    fill(51, 51, 51);
                    textAlign(CENTER);
                    text('Leaderboard', width / 2, 100);
                    textSize(20);
                    textAlign(LEFT);
                    leaderboard.sort((a, b) => b.score - a.score);
                    for (let i = 0; i < Math.min(10, leaderboard.length); i++) {
                        fill(leaderboard[i].team === 'blue' ? [0, 0, 139] : [199, 21, 133]);
                        let id = leaderboard[i].address ? leaderboard[i].address.slice(0, 12) + '...' : leaderboard[i].username.slice(0, 12);
                        text(`${i + 1}. ${id}: ${leaderboard[i].score}`, 170, 140 + i * 30);
                    }
                    drawButton(restartButton);
                } else if (gameState === 'highScore') {
                    background(245, 230, 199); // Beige
                    fill(128, 128, 128); // Gray
                    rect(150, 60, 500, 400); // Expanded box
                    textFont('Comic Neue');
                    textSize(32);
                    fill(51, 51, 51);
                    textAlign(CENTER);
                    text('Your High Scores', width / 2, 100);
                    textSize(20);
                    textAlign(LEFT);
                    highScores.sort((a, b) => b.score - a.score);
                    let startIdx = floor(scrollOffset / 30);
                    for (let i = startIdx; i < Math.min(startIdx + 12, highScores.length); i++) {
                        fill(team === 'blue' ? [0, 0, 139] : [199, 21, 133]);
                        let id = highScores[i].address ? highScores[i].address.slice(0, 12) + '...' : highScores[i].username.slice(0, 12);
                        text(`${i + 1}. ${id}: ${highScores[i].score}`, 170, 140 + (i - startIdx) * 30);
                    }
                    drawButton(restartButton);
                }
            } catch (error) {
                console.error('Draw loop error:', error);
                background(255, 0, 0); // Red screen to indicate error
                textFont('sans-serif');
                textSize(20);
                fill(255);
                textAlign(CENTER);
                text('Error rendering game. Check console.', width / 2, height / 2);
            }
        }

        function drawButton(btn) {
            try {
                fill(btn.color);
                rect(btn.x, btn.y, btn.w, btn.h);
                fill(0);
                textFont('Bubblegum Sans');
                textSize(20);
                textAlign(CENTER, CENTER);
                text(btn.text, btn.x + btn.w / 2, btn.y + btn.h / 2);
            } catch (error) {
                console.error('Draw button error:', error);
            }
        }

        async function mousePressed() {
            console.log('Mouse pressed, state:', gameState, 'Mouse:', mouseX, mouseY);
            try {
                if (gameState === 'teamSelect') {
                    if (isMouseOverButton(pinkButton)) {
                        team = 'pink';
                        introMessage = pinkIntroMessage;
                        gameState = 'intro';
                        lineIndex = 0;
                        lineAlpha = 0;
                        lineStartTime = millis();
                        showButtons = false;
                        console.log('Selected Pink team');
                        beeImg = pinkBeeImg;
                        jarImg = pinkJarImg;
                    } else if (isMouseOverButton(blueButton)) {
                        team = 'blue';
                        introMessage = blueIntroMessage;
                        gameState = 'intro';
                        lineIndex = 0;
                        lineAlpha = 0;
                        lineStartTime = millis();
                        showButtons = false;
                        console.log('Selected Blue team');
                        beeImg = blueBeeImg;
                        jarImg = blueJarImg;
                    }
                } else if (gameState === 'intro' && showButtons) {
                    if (isMouseOverButton(yesButton)) {
                        gameState = 'login';
                        console.log('Transition to login');
                    } else if (isMouseOverButton(noButton)) {
                        gameState = 'abandoned';
                    }
                } else if (gameState === 'login') {
                    if (isMouseOverButton(walletButton)) {
                        if (!walletAddress) {
                            try {
                                await window.ethereum.request({ method: 'eth_requestAccounts' });
                                signer = provider.getSigner();
                                walletAddress = await signer.getAddress();
                                isWalletConnected = true;
                                walletButton.text = `Connected: ${walletAddress.slice(0, 6)}...`;
                                console.log('Wallet connected:', walletAddress);
                                await window.ethereum.request({
                                    method: 'wallet_switchEthereumChain',
                                    params: [{ chainId: '0xaa36a7' }]
                                });
                                fetchHighScores();
                            } catch (error) {
                                console.error('Wallet connection failed:', error);
                                alert('Wallet connection failed. You can start the game with a username.');
                            }
                        } else {
                            walletAddress = null;
                            isWalletConnected = false;
                            walletButton.text = 'Sign in with Wallet';
                            console.log('Wallet disconnected');
                        }
                    } else if (isMouseOverButton(usernameButton)) {
                        let newUsername = prompt('Enter your username:');
                        if (newUsername) {
                            username = newUsername;
                            usernameButton.text = username.length > 10 ? username.slice(0, 10) + '...' : username;
                            console.log('Username set:', username);
                            fetchHighScores();
                        }
                    } else if ((walletAddress || username) && isMouseOverButton(startGameButton)) {
                        gameState = 'game';
                        jar = { x: width / 2, y: height / 2, w: 50, h: 50 };
                        score = 0;
                        lives = 3;
                        gameOver = false;
                        droplets = [];
                        bees = [];
                        fastBeeIndex = -1;
                        spawnDroplet();
                        spawnBee();
                        nextBeeSpawnTime = millis() + 10000;
                        console.log('Starting game');
                    }
                } else if (gameState === 'saveScore') {
                    if (isMouseOverButton(saveYesButton) && saveScoreChoice === null) {
                        saveScoreChoice = true;
                        if (walletAddress && contract && contractAddress !== 'YOUR_CONTRACT_ADDRESS') {
                            try {
                                let contractWithSigner = contract.connect(signer);
                                let tx = await contractWithSigner.saveScore(score, team);
                                await tx.wait();
                                console.log('Score saved to blockchain');
                                highScores.push({ address: walletAddress, score, team });
                                saveLocalHighScores();
                                fetchLeaderboard();
                            } catch (error) {
                                console.error('Failed to save score to blockchain:', error);
                                highScores.push({ address: walletAddress, score, team });
                                saveLocalHighScores();
                            }
                        } else if (username) {
                            leaderboard.push({ username, score, team });
                            highScores.push({ username, score, team });
                            saveLocalHighScores();
                            console.log('Score saved locally');
                        } else {
                            console.warn('No wallet or username, score not saved');
                        }
                    } else if (isMouseOverButton(saveNoButton) && saveScoreChoice === null) {
                        saveScoreChoice = false;
                    }
                    if (saveScoreChoice !== null && isMouseOverButton(restartButton)) {
                        gameState = 'game';
                        score = 0;
                        lives = 3;
                        gameOver = false;
                        droplets = [];
                        bees = [];
                        fastBeeIndex = -1;
                        spawnDroplet();
                        spawnBee();
                        lastDropletSpawn = millis();
                        lastBeeSpawn = millis();
                        nextBeeSpawnTime = millis() + 10000;
                    }
                } else if (gameState === 'game' || gameState === 'leaderboard' || gameState === 'highScore') {
                    if (isMouseOverButton(leaderboardButton)) {
                        gameState = 'leaderboard';
                        fetchLeaderboard();
                    } else if (isMouseOverButton(highScoreButton)) {
                        gameState = 'highScore';
                        scrollOffset = 0;
                        fetchHighScores();
                    } else if ((gameState === 'leaderboard' || gameState === 'highScore') && isMouseOverButton(restartButton)) {
                        gameState = 'game';
                        score = 0;
                        lives = 3;
                        gameOver = false;
                        droplets = [];
                        bees = [];
                        fastBeeIndex = -1;
                        spawnDroplet();
                        spawnBee();
                        lastDropletSpawn = millis();
                        lastBeeSpawn = millis();
                        nextBeeSpawnTime = millis() + 10000;
                    }
                }
            } catch (error) {
                console.error('Mouse pressed error:', error);
            }
        }

        function mouseWheel(event) {
            try {
                if (gameState === 'highScore') {
                    scrollOffset += event.delta;
                    scrollOffset = constrain(scrollOffset, 0, Math.max(0, highScores.length * 30 - 360));
                }
            } catch (error) {
                console.error('Mouse wheel error:', error);
            }
        }

        async function fetchLeaderboard() {
            try {
                leaderboard = [];
                if (walletAddress && contract && contractAddress !== 'YOUR_CONTRACT_ADDRESS') {
                    let scores = await contract.getScores();
                    for (let score of scores) {
                        leaderboard.push({
                            address: score.player,
                            score: parseInt(score.score),
                            team: score.team
                        });
                    }
                }
                if (username) {
                    leaderboard = leaderboard.concat(highScores.filter(s => s.username === username));
                }
                console.log('Leaderboard fetched:', leaderboard);
            } catch (error) {
                console.error('Failed to fetch leaderboard:', error);
            }
        }

        async function fetchHighScores() {
            try {
                highScores = [];
                if (walletAddress && contract && contractAddress !== 'YOUR_CONTRACT_ADDRESS') {
                    let scores = await contract.getPlayerScores(walletAddress);
                    for (let score of scores) {
                        highScores.push({
                            address: score.player,
                            score: parseInt(score.score),
                            team: score.team
                        });
                    }
                }
                if (username) {
                    let localScores = JSON.parse(localStorage.getItem(`highScores_${username}`) || '[]');
                    highScores = highScores.concat(localScores);
                }
                console.log('High scores fetched:', highScores);
            } catch (error) {
                console.error('Failed to fetch high scores:', error);
            }
        }

        function saveLocalHighScores() {
            try {
                if (username) {
                    let localScores = highScores.filter(s => s.username === username);
                    localStorage.setItem(`highScores_${username}`, JSON.stringify(localScores));
                }
                if (walletAddress) {
                    let localScores = highScores.filter(s => s.address === walletAddress);
                    localStorage.setItem(`highScores_${walletAddress}`, JSON.stringify(localScores));
                }
                console.log('Local high scores saved');
            } catch (error) {
                console.error('Failed to save local high scores:', error);
            }
        }

        function loadLocalHighScores() {
            try {
                let keys = Object.keys(localStorage).filter(k => k.startsWith('highScores_'));
                for (let key of keys) {
                    let scores = JSON.parse(localStorage.getItem(key) || '[]');
                    highScores = highScores.concat(scores);
                }
                console.log('Local high scores loaded:', highScores);
            } catch (error) {
                console.error('Failed to load local high scores:', error);
            }
        }

        function isMouseOverButton(btn) {
            try {
                return mouseX > btn.x && mouseX < btn.x + btn.w && mouseY > btn.y && mouseY < btn.y + btn.h;
            } catch (error) {
                console.error('isMouseOverButton error:', error);
                return false;
            }
        }

        function spawnDroplet() {
            try {
                let x = random(0, width);
                let vx = random(-1, 1);
                let vy = random(0.5, 2);
                droplets.push({ x, y: 0, vx, vy, w: 20, h: 20 });
            } catch (error) {
                console.error('Spawn droplet error:', error);
            }
        }

        function spawnBee() {
            try {
                let x = random(0, width);
                let y = random(0, height);
                let phase = 'slow';
                let speed = random(1, 2);
                let angle = random(TWO_PI);
                let vx = speed * cos(angle);
                let vy = speed * sin(angle);
                let phaseStart = millis();
                let phaseDuration = 3000;
                let phaseCycleIndex = 0;
                bees.push({ x, y, vx, vy, w: 30, h: 30, phase, phaseStart, phaseDuration, phaseCycleIndex });
                if (bees.length === 5 && fastBeeIndex === -1) {
                    fastBeeIndex = bees.length - 1;
                }
            } catch (error) {
                console.error('Spawn bee error:', error);
            }
        }

        function updateFastBeeIndex(removedIndex) {
            try {
                if (bees.length < 5) {
                    fastBeeIndex = -1;
                } else if (fastBeeIndex === removedIndex) {
                    fastBeeIndex = floor(random(bees.length));
                } else if (fastBeeIndex > removedIndex) {
                    fastBeeIndex--;
                }
            } catch (error) {
                console.error('Update fast bee index error:', error);
            }
        }

        function collides(a, b) {
            try {
                return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
            } catch (error) {
                console.error('Collision check error:', error);
                return false;
            }
        }
    </script>
</body>
</html>
